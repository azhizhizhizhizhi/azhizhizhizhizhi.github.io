<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>js面向对象小结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="javascript 的继承机制JavaScript也是面向对象的编程语言的来着有的对象的继承问题，实际开发中会很容易碰到的坑，比如拷贝，原数组，拷贝数组，拷贝对象等等，理解了继承机制之后就很容易知道问题在哪，上下通透了。面向对象的三大特征：封装、继承、多态用js实现，关乎于原型链的继承，等等，大概总结下，以后不懂的时候再来看看。内容大部分出自阮老师博客以及javascript高级程序设计。">
<meta property="og:type" content="article">
<meta property="og:title" content="js面向对象小结">
<meta property="og:url" content="http://example.com/2018/06/19/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="javascript 的继承机制JavaScript也是面向对象的编程语言的来着有的对象的继承问题，实际开发中会很容易碰到的坑，比如拷贝，原数组，拷贝数组，拷贝对象等等，理解了继承机制之后就很容易知道问题在哪，上下通透了。面向对象的三大特征：封装、继承、多态用js实现，关乎于原型链的继承，等等，大概总结下，以后不懂的时候再来看看。内容大部分出自阮老师博客以及javascript高级程序设计。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-06-19T04:13:06.000Z">
<meta property="article:modified_time" content="2018-06-19T04:18:58.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-js继承机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/19/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2018-06-19T04:13:06.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      js面向对象小结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="javascript-的继承机制"><a href="#javascript-的继承机制" class="headerlink" title="javascript 的继承机制"></a>javascript 的继承机制</h1><p>JavaScript也是面向对象的编程语言的来着<br>有的对象的继承问题，实际开发中会很容易碰到的坑，比如拷贝，原数组，拷贝数组，拷贝对象等等，理解了继承机制之后就很容易知道问题在哪，上下通透了。<br>面向对象的三大特征：封装、继承、多态<br>用js实现，关乎于原型链的继承，等等，大概总结下，以后不懂的时候再来看看。<br>内容大部分出自阮老师博客以及javascript高级程序设计。</p>
<span id="more"></span>
<h2 id="面向对象编程第一步：封装"><a href="#面向对象编程第一步：封装" class="headerlink" title="面向对象编程第一步：封装"></a>面向对象编程第一步：封装</h2><p>javascript是一种基于对象（object-based）的语言，编程时遇到的几乎所有东西都是对象，但是，他又不是真正的面向对象的编程(OPP)语言，因为es6之前都还没有class类的写法，es6有了，但也只是语法糖，本质还是关于原型链的继承</p>
<p>我们试试把属性（property）和方法（method），封装成一个对象试一试，直至从从原型对象生成一个实例对象。</p>
<h3 id="1生成实例对象的原始模式"><a href="#1生成实例对象的原始模式" class="headerlink" title="1生成实例对象的原始模式"></a>1生成实例对象的原始模式</h3><p>假定我们把猫看成是一个对象，它有名字和颜色两个属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Cat</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要根据这个原型对象的规格（schema）,生成两个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">cat1.<span class="property">name</span> = <span class="string">&quot;大毛&quot;</span>; <span class="comment">// 按照原型对象的属性赋值</span></span><br><span class="line">cat1.<span class="property">color</span> = <span class="string">&quot;黄色&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> cat2 = &#123;&#125;;</span><br><span class="line">cat2.<span class="property">name</span> = <span class="string">&quot;二毛&quot;</span>;</span><br><span class="line">cat2.<span class="property">color</span> = <span class="string">&quot;黑色&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样子就是最简单的封装了，把两个属性放到一个对象里面，但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是实例与原型之间，没有任何办法，可以看出有什么联系。</p>
<h3 id="2原始模式的改进"><a href="#2原始模式的改进" class="headerlink" title="2原始模式的改进"></a>2原始模式的改进</h3><p>我们可以写一个函数，解决代码重复的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:name,</span><br><span class="line">        <span class="attr">color</span>:color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成实例对象，就等于是在调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>，<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="title function_">cat</span>(<span class="string">&quot;二毛&quot;</span>，<span class="string">&quot;黄色&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h3 id="3构造函数模式"><a href="#3构造函数模式" class="headerlink" title="3构造函数模式"></a>3构造函数模式</h3><p>为了解决从原型对象生成实例的问题，JavaScript提供了一个构造函数（construct）模式，所谓<code>构造函数</code>，其实就是一个普通函数，但是内部使用了this变量，对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。<br>比如，猫的原型对象现在可以这样写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就可以实例化了，<br>实例化对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;二毛&quot;</span>,<span class="string">&quot;黑色&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">constructor</span> == cat)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat2.<span class="property">constructor</span> == cat)</span><br></pre></td></tr></table></figure>
<p>javascript还提供了一个<code>instancesof</code>运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1 <span class="keyword">instanceof</span> cat)<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat2 <span class="keyword">instanceof</span> cat)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="4构造函数模式的问题"><a href="#4构造函数模式的问题" class="headerlink" title="4构造函数模式的问题"></a>4构造函数模式的问题</h3><p>构造函数方法很好用，但是存在一个浪费内存的问题<br>请看，我们现在为<code>cat</code>对象添加一个不变的属性<code>type</code>（种类），再添加一个方法eat（吃）,那么，原型对象cat就变成了下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&quot;猫科动物&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃老鼠&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是采用同样的方式，生成实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;二毛&quot;</span>,<span class="string">&quot;黑色&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">type</span>)</span><br><span class="line">cat1.<span class="title function_">eat</span>()</span><br></pre></td></tr></table></figure>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(cat1.<span class="property">eat</span> == cat2.<span class="property">eat</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>能不能让<code>type</code>和<code>eat</code>方法在内存中只生成一次，然后所有实例都指向内个内存地址呢，回答是有的，那就是原型链方法prototype模式</p>
<h3 id="5-Prototype模式"><a href="#5-Prototype模式" class="headerlink" title="5 Prototype模式"></a>5 Prototype模式</h3><p>JavaScript规定，每一个构造函数都有一个<code>prototype</code>属性，指向一个对象，这个对象的所有属性和方法，都会被构造函数的实例继承<br>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">&#125;</span><br><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">type</span> = <span class="string">&quot;猫科动物&quot;</span></span><br><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&quot;吃老鼠&quot;</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>然后，生成实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line">　　<span class="keyword">var</span> cat2 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;二毛&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">type</span>); <span class="comment">// 猫科动物</span></span><br><span class="line">　　cat1.<span class="title function_">eat</span>(); <span class="comment">// 吃老鼠</span></span><br></pre></td></tr></table></figure>
<p>这时所有实例的<code>type</code>属性和<code>eat()</code>，其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">eat</span> == cat2.<span class="property">eat</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6isPrototypeOf"><a href="#6isPrototypeOf" class="headerlink" title="6isPrototypeOf()"></a>6isPrototypeOf()</h3><p>这个方法用来判断，某个<code>prototype</code>对象和某个实例之间的关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(cat1));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(cat2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;type&quot;</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h3><p><code>in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> cat1);<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;type&quot;</span> <span class="keyword">in</span> cat1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><code>in</code>运算符还可以用来遍历某个对象的所有属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> cat1)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;cat1[&quot;</span>+prop+<span class="string">&quot;]=&quot;</span>+cat1[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>上面说了，如何进行<code>封装</code>数据和方法，以及如何从原型对象生成实例。<br>这节就介绍对象之间的<code>继承</code>的五种方法<br>比如，现在有一个<code>动物</code>对象的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&quot;动物&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个<code>猫</code>对象的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么才能使<code>猫</code>继承<code>动物</code>呢？</p>
<h3 id="1-构造函数绑定"><a href="#1-构造函数绑定" class="headerlink" title="1 构造函数绑定"></a>1 构造函数绑定</h3><p>第一种方法也是最简单的方法，使用call或apply方法，将父对象的构造函数绑定在子对象上，就是在子对象构造函数中加一行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cat</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="title class_">Animal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">species</span>)<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>

<h3 id="2-prototype模式"><a href="#2-prototype模式" class="headerlink" title="2 prototype模式"></a>2 prototype模式</h3><p>第二种方法更加常见，使用prototype属性，如果<code>猫</code>的prototype对象，指向一个Animal的实例，那么所有的<code>猫</code>的实例，就能继承Animal了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = cat;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title function_">cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">species</span>);<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>
<p>代码的第一行，我们将cat的prototype对象指向一个Animal的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br></pre></td></tr></table></figure>
<p>他相当于完全删除了prototype对象原先的值，然后赋予一个新值，但是，第二行又是什么意思呢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = cat;</span><br></pre></td></tr></table></figure>
<p>原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数，如果没有<code>cat.prototype = new Animal()</code>这一行，<code>cat.prototype.constructor</code>是指向cat的，加了这一行以后，cat.prototype.constructor指向Animal</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Animal</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(cat1.<span class="property">constructor</span> == cat.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，在运行”Cat.prototype &#x3D; new Animal();”这一行之后，cat1.constructor也指向Animal！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(cat1.<span class="property">constructor</span> == <span class="title class_">Animal</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</p>
<p>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，那么下一步必然是在新的prototype对象上加上constructor属性，并将这个属性指回原来的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="property"><span class="keyword">prototype</span></span> = &#123;&#125;</span><br><span class="line">o.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = o</span><br></pre></td></tr></table></figure>
<h3 id="3-直接继承prototype"><a href="#3-直接继承prototype" class="headerlink" title="3 直接继承prototype"></a>3 直接继承prototype</h3><p>第三种方法是第二种方法的改进，由于Animal对象中，不变的属性都可以直接写入Animal.prototype，所以，我们也可以让Cat()跳过Animal(),直接继承Animal.prototype。<br>比如，现在我们将Animal对象改写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">species</span> = <span class="string">&quot;动物&quot;</span>；</span><br></pre></td></tr></table></figure>
<p>然后，Cat的prototype对象，指向Animal的prototype对象，这样就完成了继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">species</span>)<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。</p>
<p>所以，上面这一段代码其实是有问题的。请看第二行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>;</span><br></pre></td></tr></table></figure>
<p>这一句实际上把Animal.prototype对象的constructor属性也改掉了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// Cat</span></span><br></pre></td></tr></table></figure>
<h3 id="4-利用空对象作为中介"><a href="#4-利用空对象作为中介" class="headerlink" title="4 利用空对象作为中介"></a>4 利用空对象作为中介</h3><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">　　F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">　　<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">　　<span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>;</span><br></pre></td></tr></table></figure>
<p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>); <span class="comment">// Animal</span></span><br></pre></td></tr></table></figure>
<p>我们将上面的方法，封装成一个函数，便于使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">　　<span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">  　F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">　　<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">　　<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">　　<span class="title class_">Child</span>.<span class="property">uber</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，方法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">extend</span>(<span class="title class_">Cat</span>,<span class="title class_">Animal</span>);</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(cat1.<span class="property">species</span>); <span class="comment">// 动物</span></span><br></pre></td></tr></table></figure>
<p>这个extend函数，就是YUI库如何实现继承的方法。<br>另外，说明一点，函数体最后一行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property">uber</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>
<p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h3 id="5-拷贝继承"><a href="#5-拷贝继承" class="headerlink" title="5 拷贝继承"></a>5 拷贝继承</h3><p>上面说的采用prototype对象，实现继承，我们也可以换一种思路，纯粹采用<code>拷贝</code>方法实现，简单说，如果被父对象的所有属性和方法，拷贝进子对象，不就实现了继承了吗，所以，这就是我们第五种方法<br>首先,还是把Animal的所有不变属性，都放到它的prototype对象上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">species</span> = <span class="string">&quot;动物&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后，在写一个函数，实现属性拷贝的目的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend2</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">　　<span class="keyword">var</span> p = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">　　<span class="keyword">var</span> c = <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　c[i] = p[i];</span><br><span class="line">　　&#125;</span><br><span class="line">　　c.<span class="property">uber</span> = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父元素的prototype对象中的属性，一个一个的拷贝给child对象的prototype对象，使用的时候，这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">extend2</span>(<span class="title class_">Cat</span>,<span class="title class_">Animal</span>);</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;大毛&quot;</span>,<span class="string">&quot;黄色&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cat1.<span class="property">species</span>);<span class="comment">//动物</span></span><br></pre></td></tr></table></figure>

<h2 id="非构造函数的继承"><a href="#非构造函数的继承" class="headerlink" title="非构造函数的继承"></a>非构造函数的继承</h2><p>第一部分介绍了封装，第二部分介绍了使用构造函数实现继承<br>这部分就用 <code>非构造函数</code>实现<code>继承</code></p>
<h3 id="1-对非构造函数的继承"><a href="#1-对非构造函数的继承" class="headerlink" title="1 对非构造函数的继承"></a>1 对<code>非构造函数</code>的继承</h3><p>比如现在有个对象，叫创明工作室，还有个是WEB组成员</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cmgzs = &#123;</span><br><span class="line">    <span class="attr">nation</span>:<span class="string">&quot;创明工作室&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> web = &#123;</span><br><span class="line">    <span class="attr">career</span>:<span class="string">&quot;组员&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想下我们怎才能让web继承cmgzs呢，就是意思是，怎样才能知道web是cmgzs的下属部门呢<br>两个都是不同对象，不是构造函数(constructor)，无法使用构造函数方式是实现<code>继承</code></p>
<h3 id="2-objecet-方法。"><a href="#2-objecet-方法。" class="headerlink" title="2 objecet()方法。"></a>2 objecet()方法。</h3><p>下面是json格式发明者提出的一个object方法，object()可以做到这一点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">　　　　<span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">　　　　F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>这个object()函数，其实只做了一件事，就是把子对象的prototype属性，指向父元素，从而使得子对象与父对象连在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lizhi = <span class="title function_">object</span>(cmgzs)</span><br><span class="line">lizhi.<span class="property">career</span> = <span class="string">&quot;萌新&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lizhi.<span class="property">nation</span>)</span><br></pre></td></tr></table></figure>
<p>使用的时候，就是在父对象的基础上，生成子对象，然后加上子对象本身的属性，这时，子对象已经继承了父对象的属性了。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。<br>下面这个函数，就是在做拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">function</span> <span class="title function_">extendCopy</span>(<span class="params">p</span>) &#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123; </span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.<span class="property">uber</span> = p;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，这样写；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">var</span> <span class="title class_">Doctor</span> = <span class="title function_">extendCopy</span>(<span class="title class_">Chinese</span>);</span><br><span class="line">　　<span class="title class_">Doctor</span>.<span class="property">career</span> = <span class="string">&#x27;医生&#x27;</span>;</span><br><span class="line">　　<span class="title function_">alert</span>(<span class="title class_">Doctor</span>.<span class="property">nation</span>); <span class="comment">// 中国</span></span><br></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。<br>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。<br>实现，数组和对象的深拷贝不考虑funciton</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">p, c</span>) &#123;</span><br><span class="line">　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">　　　　　　c[i] = (p[i].<span class="property">constructor</span> === <span class="title class_">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">　　　　　　<span class="title function_">deepCopy</span>(p[i], c[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候，这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lizhi = <span class="title function_">deepCopy</span>(cmgzs)</span><br><span class="line">cmgzs.<span class="property">bitrhPlaces</span> = [<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;asdfasf&#x27;</span>,<span class="string">&#x27;gdfg&#x27;</span>]</span><br><span class="line">lizhi.<span class="property">bitrhPlaces</span>.<span class="title function_">push</span>(<span class="string">&quot;asdfsdf&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmgzs.<span class="property">bitrhPlaces</span></span><br><span class="line">[<span class="string">&quot;123&quot;</span>, <span class="string">&quot;asdfasf&quot;</span>, <span class="string">&quot;gdfg&quot;</span>]</span><br><span class="line"></span><br><span class="line">lizhi.<span class="property">bitrhPlaces</span></span><br><span class="line">[<span class="string">&quot;123&quot;</span>, <span class="string">&quot;asdfasf&quot;</span>, <span class="string">&quot;gdfg&quot;</span>, <span class="string">&quot;asdfsdf&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这样push的时候父类对象就不会跟着改变了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本的js继承机制就总结完毕了，可能还有很多不对的地方，希望大家指正。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/19/js%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/" data-id="cl70o66fn000kk8u9a58u7fmf" data-title="js面向对象小结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/23/%E5%A4%B4%E6%9D%A1%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          头条一面面经
        
      </div>
    </a>
  
  
    <a href="/2018/06/18/javascript%E2%80%94-%E9%97%AD%E5%8C%85%E3%80%81this%E5%B0%8F%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">javascript—-闭包、this小结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E6%96%87/">杂文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/%E7%BD%91%E7%BB%9C/">网络</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag">python数据分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%BB%E5%8A%A1/" rel="tag">任务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%8D%E6%B5%81/" rel="tag">免流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" rel="tag">技术分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E8%AE%B0-%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/" rel="tag">日记-记录生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E6%96%87/" rel="tag">杂文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/" rel="tag">生活杂谈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E7%99%BD/" rel="tag">表白</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%83%B3/" rel="tag">随想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%83%B3%E9%9A%8F%E8%AE%B0/" rel="tag">随想随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 10px;">python数据分析</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E4%BB%BB%E5%8A%A1/" style="font-size: 10px;">任务</a> <a href="/tags/%E5%85%8D%E6%B5%81/" style="font-size: 10px;">免流</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 13.33px;">博客</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" style="font-size: 10px;">技术分享</a> <a href="/tags/%E6%97%A5%E8%AE%B0-%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/" style="font-size: 13.33px;">日记-记录生活</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E6%9D%82%E6%96%87/" style="font-size: 10px;">杂文</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/" style="font-size: 16.67px;">生活杂谈</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%A1%A8%E7%99%BD/" style="font-size: 10px;">表白</a> <a href="/tags/%E9%9A%8F%E6%83%B3/" style="font-size: 10px;">随想</a> <a href="/tags/%E9%9A%8F%E6%83%B3%E9%9A%8F%E8%AE%B0/" style="font-size: 10px;">随想随记</a> <a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 10px;">面经</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/16/%E5%B0%8F%E6%9D%8E%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%BA/">小李是个什么样的人</a>
          </li>
        
          <li>
            <a href="/2020/05/05/%E5%A4%A7%E7%90%86/">大理</a>
          </li>
        
          <li>
            <a href="/2020/05/05/freedom/">freedom</a>
          </li>
        
          <li>
            <a href="/2019/12/22/%E8%87%AA%E5%B7%B1%E5%8A%A0%E6%B2%B9%E6%89%93%E6%B0%94%E5%93%88/">自己加油打气哈</a>
          </li>
        
          <li>
            <a href="/2019/12/01/%E6%97%A0%E9%A2%98/">无题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>